ynoip.cn

7278   7279   7280   

根据你提供的四道题目和对应的代码，我将逐一给出每道题的题解，包括题目大意、解题思路和代码实现分析。

---

## 1. 题目一：虚无 (ix)

### 题目大意

有 `n` 个圆柱体盒子，每个盒子高度为 `h_i`，底面半径等于高度。  

一个盒子可以放入另一个盒子中当且仅当前者的高度严格小于后者。  

一个盒子只能直接放入一个盒子中，但可以嵌套（即盒子里有盒子，再放入另一个盒子）。  

问最少能剩下多少个盒子（无法被其他盒子装入的盒子数）。

### 解题思路

这是一个典型的 **最长非严格上升子序列（LIS）** 的变形问题。  

我们要求的是：**最少能分成多少个非严格上升子序列**。  

根据 Dilworth 定理：  

> 最小链划分 = 最长反链长度  

> 这里“链”是嵌套关系（非严格递减），“反链”是不可比较的（严格递增）。

因此，我们要求的是 **最长严格上升子序列的长度**。

### 代码分析

```cpp

#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5;

int n, a[N];

multiset<int> s;

int main() {

    // 输入

    cin >> n;

    for (int i = 1; i <= n; i++) cin >> a[i];

    sort(a + 1, a + n + 1);

    // 贪心：维护一个 multiset，表示当前每个链的末尾元素

    for (int i = n; i >= 1; i--) {

        auto it = s.upper_bound(a[i]);

        if (it != s.end()) s.erase(it);

        s.insert(a[i]);

    }

    cout << s.size() << '\n';

    return 0;

}

```

- 排序后，从大到小遍历。

- 使用 `multiset` 维护当前所有链的末尾元素。

- 对于当前元素 `a[i]`，找到大于它的最小末尾，替换它（相当于接在该链后面）。

- 如果找不到，就新开一个链。

- 最终 `s.size()` 就是最少链数（即答案）。

---

## 2. 题目二：丰饶偶遇 (cross)

### 题目大意

有 `m` 轮攻击，每轮：

1. 怪物使用 `a_i` 次回血技能（每层回血 `R`）。

2. 你可以选择是否使用技能（最多 `K` 次）：

   - 减少一层回血效果（若 `r > 0`）

   - 增加一层持续伤害效果（每层伤害 `C`）

3. 回血效果生效：`r * R`

4. 固定伤害：`X`

5. 持续伤害生效：`c * C`

求最大血量下降值（可为负）。

### 解题思路

这是一个贪心 + 模拟题。  

核心在于 **何时使用技能** 能最大化伤害。  

- 如果当前回血层数 `r > 0`，使用技能可以立即减少回血并增加持续伤害。

- 如果 `r = 0`，使用技能只增加持续伤害，但会消耗一次技能次数，需要判断是否值得。

### 代码分析

```cpp

#include<bits/stdc++.h>

using namespace std;

__int128 n, K, R, X, C, tot, a[2000005], vis[2000005];

__int128 r = 0, c = 0, ans = 0;

// 读入 __int128

// 贪心：维护一个优先队列，存储未来可能使用技能的收益

```

- 使用 `__int128` 防止溢出。

- 维护 `r` 表示当前回血层数，`c` 表示持续伤害层数。

- 每轮先加 `a_i` 到 `r`。

- 如果 `r > 0` 且还有技能次数，优先使用技能（减少回血，增加持续伤害）。

- 如果 `r = 0`，则根据未来收益决定是否使用技能。

- 每轮结算：`ans -= r * R; ans += X; ans += c * C;`

---

## 3. 题目三：智识探测 (detect)

### 题目大意

构造一棵 `n` 个节点的有根树，使得每个节点的 **观测参数**（子树大小 + 到根的距离）的不同值尽可能多。  

输出最大不同值个数，并输出一种方案。

### 解题思路

观测参数 = `size[u] + dep[u]`。  

要让不同值尽可能多，需要让这些值尽量分散。  

一种构造方法：

- 根节点为 1。

- 让树形成一条链，这样每个节点的 `size[u]` 和 `dep[u]` 都不同，且和也不同。

### 代码分析

```cpp

#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

struct edge { int u, v; };

vector<int> adj[N];

void solve(int n) {

    vector<edge> ans;

    for (int i = 2; i <= n; i++) {

        int u = (i % 2 == 0) ? i - 1 : i - 2;

        ans.push_back({u, i});

    }

    cout << n - 1 << " " << 1 << "\n";

    for (edge &ed : ans) {

        cout << ed.u << " " << ed.v << "\n";

    }

}

```

- 对于 `n >= 4`，构造方法：节点 `i` 连向 `i-1`（偶数）或 `i-2`（奇数），形成一条链。

- 对于小数据 `n <= 6` 特判输出。

---

## 4. 题目四：毁灭预警 (warning)

### 题目大意

给定一棵 `n` 个节点的树，每个节点有重要度 `w_i`。  

选择一个连通块（包含起点），满足：

- 起点到连通块内任意节点的路径上的边承载量 ≥ 连通块大小。

- 起点重要度算两次。

求所有合法连通块的（起点重要度 + 所有节点重要度）之和的期望（模 998244353）。

### 解题思路

树形 DP + 换根 DP。  

- `f[u][j]` 表示以 `u` 为根，连通块大小为 `j` 的总重要度和。

- `cnt[u][j]` 表示方案数。

- 转移时枚举子树大小，背包合并。

- 换根 DP 计算每个点作为起点的贡献。

### 代码分析

```cpp

#include <bits/stdc++.h>

using namespace std;

const int N = 5080, MOD = 998244353;

int n, k, val[N], f[N][N], cnt[N][N], siz[N];

// 树形 DP

void dfs1(int u, int anc) {

    siz[u] = 1;

    f[u][1] = val[u];

    cnt[u][1] = 1;

    for (int v : adj[u]) {

        if (v == anc) continue;

        dfs1(v, u);

        // 背包合并

        for (int j = siz[u]; j >= 1; j--) {

            for (int i = 1; i <= min(siz[v], k); i++) {

                // 更新 f 和 cnt

            }

        }

        siz[u] += siz[v];

    }

}

// 换根 DP

void dfs2(int u, int anc) {

    // 计算以 u 为起点的贡献

    // 换根更新

}

```

- 第一次 DFS 计算以 1 为根的 DP 值。

- 第二次 DFS 换根，计算每个点作为起点的贡献。

- 最终答案 = `总重要度和 / 总方案数`（模逆元）。

---

## 总结

这四道题涵盖了：

1. **贪心 + Dilworth 定理**（ix）

2. **贪心模拟 + 大数处理**（cross）

3. **构造 + 树的性质**（detect）

4. **树形 DP + 换根 DP + 模运算**（warning）

每道题都需要对问题本质有深刻理解，并运用合适的算法和数据结构解决。